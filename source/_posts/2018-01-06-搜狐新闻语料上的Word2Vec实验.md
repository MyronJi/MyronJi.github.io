---
title: 搜狐新闻语料上的Word2Vec实验
date: 2018-01-06 14:58:21
updated: 
categories: Notes
tags: [NLP, Machine Learning]
---

根据网上的各种教程学习自然语言处理的初级操作，记录实践流程以及学习心得。
<!--more-->
# 环境搭建
- 基础环境：
    {% note default %}
    ubuntu server 16.04 + Python3.6
    {% endnote %}
- 安装NLP工具包gensim，这里包含了今天的主角：Word2Vec
    {% note info %}
    pip install --upgrade gensim
    {% endnote %}
- 安装中文分词工具包jieba
    {% note info %}
    pip install jieba
    {% endnote %}

# 处理语料
处理语料是所有步骤中最重要也是最花时间的步骤，我们需要一份没有干扰数据，分词合理的预料来喂给模型去训练。
1. 下载搜狐新闻语料（链接:https://pan.baidu.com/s/1bpcQ083 密码: fcxq）。解压后得到许多txt文件。新闻内容应该是用爬虫爬下来的，随机选择几个打开看一下，发现格式都一样的新闻网址 `+` \`1\`2 `+` 标题 `+` \`1\`2 `+` 正文 。
    ![](\2018/01/06/搜狐新闻语料上的Word2Vec实验\souhunews.png)
2. 用去除网址,用句号替代分隔符'\`1`2'，再用jieba来分词：
    ```python
    pattern_http = re.compile(r'(http.*?)`1`2')
    jieba.cut(pattern_http.sub('', line).replace('`1`2','。').strip(),cut_all=False)]
    ```
3. 去除停用词，并且用空格分隔单词：
    ```python
    stop_words = codecs.open(u'stop_words.txt', 'r', encoding='utf-8')
    stop_list = {}.fromkeys([line.strip() for line in stop_words])

    for sentence in sentences_iter:
        if len(sentence) > 0:
            output = ' '
            for word in sentence:
                if word not in stop_list:
                    output +=word + ' '
    ```
    {% note danger %}
    标点符号可以提高分词准确度，所以先分词再去除标点符号。
    {% endnote %}
4. 提取中文字符(去除数字和标点)，并用空格分隔单词：
    ```python
    output_sentence = " ".join(pattern_chinese.findall(output))
    ```
5. 批量处理所有txt文件（4.6 G），把结果写入新的文件中。整个任务跑了2小时，最后我们得到了一份干净的语料（3.6 G）。效果如下，看着还不错：
![](\2018/01/06/搜狐新闻语料上的Word2Vec实验\souhuyuliao.png)

# 模型训练
得益于强大的gensim包，模型训练很简单。
1. 设定好参数，再把数据喂给模型训练就ok了。
    设定几个关键参数，其他的就用默认的：
    > size=300：用300维的向量表示一个词。
    > window=5：表示当前词与预测词在一个句子中的最大距离为5。
    > min_count=5: 舍弃词频小于5的词。
    > workers=3：3线程训练。

    ```python
    inFile = 'souhu_jieba.txt'
    outFile_model = 'souhu_news_model'
    outFile_vec = 'souhu_news_vector'
    sentences = LineSentence(inFile)

    model = Word2Vec(sentences, size=300, window=5, min_count=5, workers=3)
    # trim unneeded model memory = use(much) less RAM
    # model.init_sims(replace=True)
    model.save(outFile_model)
    model.wv.save_word2vec_format(outFile_vec, binary=False)
    ```
2. 保存模型和词向量：
    ```python
    model.save(outFile_model)
    model.wv.save_word2vec_format(outFile_vec, binary=False)
    ```

# 查询结果
终于到了最有意思的阶段了，现在我们可以查询词向量以，相似词以及离群词等。
## 加载模型
```python
model = gensim.models.Word2Vec.load('souhu_news_model')
```
## 查询词向量
```python
word1 = u'计算机'
word2 = u'特斯拉'
if word1 in model:
    print(u"'%s'的词向量为： " % word1)
    print(model[word1])
else:
    print(u'单词不在字典中！')
```
## 查询相似
1. 相似词
```python
result = model.most_similar(word2)
print(u"\n与'%s'最相似的词为： " % word2)
for e in result:
    print('%s: %f' % (e[0], e[1]))
```
2. 相似度
```python
print(u"\n'%s'与'%s'的相似度为： " % (word1, word2))
print(model.similarity(word1, word2))
```
## 查询不相似词
```python
print(u"\n与'%s'最相似，而与'%s'最不相似的词为： " % (word1, word2))
temp = (model.most_similar(positive=[word1], negative=[word2], topn=1))
print('%s: %s' % (temp[0][0], temp[0][1]))
```
## 查询离群词
```python
print(u"\n'车 房 年轻人 工作'中的离群词为： ")
print(model.doesnt_match(u"车 房 年轻人 工作".split()))
```
{% note info%}
由于每个词都有不同的向量，所以计算向量之间的cos来得到距离，从而得到相似度。
{% endnote %}

# 附上参数的详细说明
```python
class gensim.models.word2vec.Word2Vec(sentences=None,size=100,alpha=0.025,window=5, min_count=5, 
    max_vocab_size=None, sample=0.001,seed=1, workers=3,min_alpha=0.0001, sg=0, hs=0, negative=5, 
    cbow_mean=1, hashfxn=<built-in function hash>,iter=5,null_word=0, trim_rule=None, 
    sorted_vocab=1, batch_words=10000)
```
{% note default %}
- sentences：可以是一个list，对于大语料集，建议使用BrownCorpus,Text8Corpus或ineSentence构建。
- sg： 用于设置训练算法，默认为0，对应CBOW算法；sg=1则采用skip-gram算法。
- size：是指特征向量的维度，默认为100。大的size需要更多的训练数据,但是效果会更好. 推荐值为几十到几百。
- window：表示当前词与预测词在一个句子中的最大距离是多少
- alpha: 是学习速率
- seed：用于随机数发生器。与初始化词向量有关。
- min_count: 可以对字典做截断. 词频少于min_count次数的单词会被丢弃掉, 默认值为5
- max_vocab_size: 设置词向量构建期间的RAM限制。如果所有独立单词个数超过这个，则就消除掉其中最不频繁的一个。每一千万个单词需要大约1GB的RAM。设置成None则没有限制。
- sample: 高频词汇的随机降采样的配置阈值，默认为1e-3，范围是(0,1e-5)
- workers参数控制训练的并行数。
- hs: 如果为1则会采用hierarchicalsoftmax技巧。如果设置为0（default），则negative sampling会被使用。
- negative: 如果>0,则会采用negativesampling，用于设置多少个noise words
- cbow_mean: 如果为0，则采用上下文词向量的和，如果为1（default）则采用均值。只有使用CBOW的时候才起作用。
- hashfxn： hash函数来初始化权重。默认使用python的hash函数
- iter： 迭代次数，默认为5
- trim_rule： 用于设置词汇表的整理规则，指定那些单词要留下，哪些要被删除。可以设置为None（min_count会被使用）或者一个接受()并返回RULE_DISCARD,utils.RULE_KEEP或者utils.RULE_DEFAULT的函数。
- sorted_vocab： 如果为1（default），则在分配word index 的时候会先对单词基于频率降序排序。
- batch_words：每一批的传递给线程的单词的数量，默认为10000
{% endnote %}